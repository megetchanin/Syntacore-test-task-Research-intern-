# Syntacore-test-task-Research-intern
В репозитории - файл проекта c++ и входной файл. 
Сборка проекта:
Windows: 
1) Собрать файл посредством make, изменив расширение выходного файла на .exe
2) запустить исполняемый файл (текстовый файл входных данных должен быть в той же директории, что и исполняемый)

Linux:
1) Собрать файл посредством make
2) Запустить собранный исполняемый файл (текстовый файл входных данных должен быть в той же директории, что и исполняемый)

В коде закомментированы куски, с помощью которых можно было бы сделать многопоточное вычисление.
Алгоритмическая сложность:
*функция xor и нахождения весов - (n+l)*2^n, где n - количество входных векторов, l - количество символов, из которого состоят входные векторы;
*функция перевода строк в число - nl, где n - количество входных векторов, l - количество символов, из которого состоят входные векторы;
*В результате сложность O(2^n)

Затраты по памяти: 
В данной реализации больше всего памяти требуется для вектора строк: n*sizeof(std::string), где n - число входных векторов, sizeof(std::string) - зависит от архитектуры (на моей машине был 28/40 для x86/x64).* Требуется еще несколько переменных, что составляет константные затраты, а также выходной массив, хранящий количество векторов, соответствующих весу - для него нужно K*sizeof(unsigned long long) байт, где K - наибольший по счету ненулевой бит входных векторов.*

Основные ограничения реализации - быстрорастущая сложность алгоритма сложения и возможное переполнение некоторых переменных (в частности, одной в основной функции, которая пробегает значения от 0 до 2^n - при достаточно большом n может произойти переполнение). Стоит отметить тот факт, что в ряде случаев можно заменить этот сложный алгоритм на расчет биноминальных коэффициентов и коэффициента "повторения" наибольшего и нулевого весов, однако строгие условия для возможности использования такого решения не были определены.
